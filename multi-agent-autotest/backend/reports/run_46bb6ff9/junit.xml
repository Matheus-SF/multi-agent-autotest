<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="4" skipped="0" tests="7" time="0.376" timestamp="2026-02-23T17:39:50.260389+00:00" hostname="871a36f2bf9a"><testcase classname="test_generated" name="test_run_tests_code_dir_not_exist" time="0.006"><failure message="AssertionError: assert ('stderr' in &lt;MagicMock name='run().stderr' id='131768467010320'&gt; or 'stdout' in &lt;MagicMock name='run().stderr' id='131768467010320'&gt;)&#10; +  where &lt;MagicMock name='run().stderr' id='131768467010320'&gt; = CoverageResult(success=False, coverage_pct=0.0, uncovered_lines={}, tests_passed=0, tests_failed=0, failed_tests=None, error_output=&lt;MagicMock name='run().stderr' id='131768467010320'&gt;).error_output&#10; +  and   &lt;MagicMock name='run().stderr' id='131768467010320'&gt; = CoverageResult(success=False, coverage_pct=0.0, uncovered_lines={}, tests_passed=0, tests_failed=0, failed_tests=None, error_output=&lt;MagicMock name='run().stderr' id='131768467010320'&gt;).error_output">def test_run_tests_code_dir_not_exist():
        with patch('executor.subprocess.run') as mock_run, \
             patch('executor.Path.exists', return_value=False):
            result = run_tests('/invalid/code_dir', '/valid/tests_dir')
            assert not result.success
            assert result.coverage_pct == 0.0
            assert result.uncovered_lines == {}
&gt;           assert "stderr" in result.error_output or "stdout" in result.error_output
E           AssertionError: assert ('stderr' in &lt;MagicMock name='run().stderr' id='131768467010320'&gt; or 'stdout' in &lt;MagicMock name='run().stderr' id='131768467010320'&gt;)
E            +  where &lt;MagicMock name='run().stderr' id='131768467010320'&gt; = CoverageResult(success=False, coverage_pct=0.0, uncovered_lines={}, tests_passed=0, tests_failed=0, failed_tests=None, error_output=&lt;MagicMock name='run().stderr' id='131768467010320'&gt;).error_output
E            +  and   &lt;MagicMock name='run().stderr' id='131768467010320'&gt; = CoverageResult(success=False, coverage_pct=0.0, uncovered_lines={}, tests_passed=0, tests_failed=0, failed_tests=None, error_output=&lt;MagicMock name='run().stderr' id='131768467010320'&gt;).error_output

/tests/test_generated.py:17: AssertionError</failure></testcase><testcase classname="test_generated" name="test_run_tests_tests_dir_not_exist" time="0.003"><failure message="assert ('stderr' in &quot;name 'p' is not defined&quot; or 'stdout' in &quot;name 'p' is not defined&quot;)&#10; +  where &quot;name 'p' is not defined&quot; = CoverageResult(success=False, coverage_pct=0.0, uncovered_lines={}, tests_passed=0, tests_failed=0, failed_tests=None, error_output=&quot;name 'p' is not defined&quot;).error_output&#10; +  and   &quot;name 'p' is not defined&quot; = CoverageResult(success=False, coverage_pct=0.0, uncovered_lines={}, tests_passed=0, tests_failed=0, failed_tests=None, error_output=&quot;name 'p' is not defined&quot;).error_output">def test_run_tests_tests_dir_not_exist():
        with patch('executor.subprocess.run') as mock_run, \
             patch('executor.Path.exists', side_effect=lambda *args, **kwargs: p != Path('/valid/tests_dir/coverage.xml')):
            result = run_tests('/valid/code_dir', '/invalid/tests_dir')
            assert not result.success
            assert result.coverage_pct == 0.0
            assert result.uncovered_lines == {}
&gt;           assert "stderr" in result.error_output or "stdout" in result.error_output
E           assert ('stderr' in "name 'p' is not defined" or 'stdout' in "name 'p' is not defined")
E            +  where "name 'p' is not defined" = CoverageResult(success=False, coverage_pct=0.0, uncovered_lines={}, tests_passed=0, tests_failed=0, failed_tests=None, error_output="name 'p' is not defined").error_output
E            +  and   "name 'p' is not defined" = CoverageResult(success=False, coverage_pct=0.0, uncovered_lines={}, tests_passed=0, tests_failed=0, failed_tests=None, error_output="name 'p' is not defined").error_output

/tests/test_generated.py:26: AssertionError</failure></testcase><testcase classname="test_generated" name="test_run_tests_timeout" time="0.001" /><testcase classname="test_generated" name="test_parse_coverage_file_not_exist" time="0.001"><failure message="FileNotFoundError">def test_parse_coverage_file_not_exist():
        with patch('executor.ET.parse', side_effect=FileNotFoundError):
&gt;           result = _parse_coverage(Path('/invalid/coverage.xml'))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/tests/test_generated.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
executor.py:101: in _parse_coverage
    tree = ET.parse(coverage_xml)
           ^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock name='parse' id='131768467265616'&gt;
args = (PosixPath('/invalid/coverage.xml'),), kwargs = {}
effect = &lt;class 'FileNotFoundError'&gt;

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
&gt;               raise effect
E               FileNotFoundError

/usr/local/lib/python3.11/unittest/mock.py:1183: FileNotFoundError</failure></testcase><testcase classname="test_generated" name="test_parse_coverage_malformed_xml" time="0.001"><failure message="xml.etree.ElementTree.ParseError: &lt;no detail available&gt;">def test_parse_coverage_malformed_xml():
        with patch('executor.ET.parse', side_effect=ET.ParseError):
&gt;           result = _parse_coverage(Path('/malformed/coverage.xml'))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/tests/test_generated.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
executor.py:101: in _parse_coverage
    tree = ET.parse(coverage_xml)
           ^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/unittest/mock.py:1124: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/unittest/mock.py:1128: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MagicMock name='parse' id='131768467008848'&gt;
args = (PosixPath('/malformed/coverage.xml'),), kwargs = {}
effect = &lt;class 'xml.etree.ElementTree.ParseError'&gt;

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
&gt;               raise effect
E               xml.etree.ElementTree.ParseError: &lt;no detail available&gt;

/usr/local/lib/python3.11/unittest/mock.py:1183: ParseError</failure></testcase><testcase classname="test_generated" name="test_parse_junit_file_not_exist" time="0.001" /><testcase classname="test_generated" name="test_parse_junit_malformed_xml" time="0.001" /></testsuite></testsuites>